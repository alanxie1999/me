# 1. 删除旧脚本
sudo rm -f /usr/local/bin/ipip-ddns-keeper.sh

# 2. 重新运行管理脚本，再次安装该隧道
# (或者如果觉得重填参数麻烦，可以直接把下面这段"纯净版keeper生成命令"复制到服务器运行)
复制下面代码执行生成新的

cat >/usr/local/bin/ipip-ddns-keeper.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

TUN_NAME="${1:-}"
if [[ -z "$TUN_NAME" ]]; then
  echo "Usage: $0 <tun_name>" >&2
  exit 2
fi

CONF_DIR="/etc/ipip-ddns"
CONF_FILE="${CONF_DIR}/${TUN_NAME}.env"
STATE_DIR="/run/ipip-ddns"
mkdir -p "$STATE_DIR"
STATE_FILE="${STATE_DIR}/${TUN_NAME}.state"
PERSIST_FILE="${CONF_DIR}/${TUN_NAME}.state"
LOCK_FILE="${STATE_DIR}/${TUN_NAME}.lock"

if [[ ! -f "$CONF_FILE" ]]; then
  echo "Config not found: $CONF_FILE" >&2
  exit 1
fi

source "$CONF_FILE"

: "${MODE:?v4|v6}"
: "${DDNS_NAME:?}"
: "${LOCAL_IP:?}"
: "${VIP_CIDR:?}"
: "${REMOTE_VIP:?}"

# 更新 env 中的 RESOLVED_IP 字段
update_env_resolved_ip() {
  local env_file="$CONF_FILE" tmp
  tmp="$(mktemp "${env_file}.XXXXXX")" || return 0
  if grep -q '^RESOLVED_IP=' "$env_file" 2>/dev/null; then
    sed 's/^RESOLVED_IP=.*/RESOLVED_IP='"$REMOTE_IP"'/' "$env_file" >"$tmp" 2>/dev/null || { rm -f "$tmp"; return 0; }
  else
    cat "$env_file" >"$tmp" 2>/dev/null || { rm -f "$tmp"; return 0; }
    printf '\nRESOLVED_IP=%s\n' "$REMOTE_IP" >>"$tmp" 2>/dev/null || { rm -f "$tmp"; return 0; }
  fi
  mv -f "$tmp" "$env_file" 2>/dev/null || rm -f "$tmp" 2>/dev/null || true
}

resolve_ip() {
  if [[ "$MODE" == "v6" ]]; then
    getent hosts "$DDNS_NAME" | awk '{print $1}' | grep -E '^[0-9a-fA-F:]+$' | head -n1 || \
    dig +short AAAA "$DDNS_NAME" | head -n1 || \
    ping6 -c1 "$DDNS_NAME" 2>/dev/null | grep -Eo '([0-9a-fA-F:]+)' | head -n1 || true
  else
    getent hosts "$DDNS_NAME" | awk '{print $1}' | grep -E '^[0-9.]+$' | head -n1 || \
    dig +short A "$DDNS_NAME" | head -n1 || \
    ping -4 -c1 "$DDNS_NAME" 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true
  fi
}

with_lock() { exec 9>"$LOCK_FILE"; flock -n 9; }

# 解析（带重试）
resolve_ip_try() {
  local name="$1" mode="$2" ip="" attempt=0
  while (( attempt < 3 )); do
    if [[ "$mode" == "v6" ]]; then
      ip=$(getent hosts "$name" | awk '{print $1}' | grep -E '^[0-9a-fA-F:]+$' | head -n1 || true)
      [[ -z "$ip" ]] && ip=$(dig +short AAAA "$name" | head -n1 || true)
    else
      ip=$(getent hosts "$name" | awk '{print $1}' | grep -E '^[0-9.]+$' | head -n1 || true)
      [[ -z "$ip" ]] && ip=$(dig +short A "$name" | head -n1 || true)
    fi
    [[ -n "$ip" ]] && { echo "$ip"; return 0; }
    sleep 1; ((attempt++))
  done
  echo ""
}

# 幂等重建接口/地址/路由
ensure_ipip_stack() {
  local name="$1" mode="$2" local_ip="$3" remote_ip="$4" vip_cidr="$5" remote_vip="$6"
  
  # 关闭接口
  ip link set "$name" down 2>/dev/null || true
  
  if [[ "$mode" == "v6" ]]; then
    # 删除旧隧道
    ip -6 tunnel del "$name" 2>/dev/null || true
    
    # 创建新隧道
    if ! ip link add name "$name" type ip6tnl local "$local_ip" remote "$remote_ip" mode any 2>/dev/null; then
      echo "$(date) $name: 创建 IPv6 隧道失败" >&2
      return 1
    fi
    
    # 清理旧地址并添加新地址
    ip -6 addr flush dev "$name" 2>/dev/null || true
    if ! ip -6 addr add "$vip_cidr" dev "$name" 2>/dev/null; then
      echo "$(date) $name: 添加 IPv6 地址失败" >&2
      return 1
    fi
  else
    # 删除旧隧道
    ip tunnel del "$name" 2>/dev/null || true
    
    # 创建新隧道
    if ! ip tunnel add "$name" mode ipip remote "$remote_ip" local "$local_ip" ttl 64 2>/dev/null; then
      echo "$(date) $name: 创建 IPIP 隧道失败" >&2
      return 1
    fi
    
    # 清理旧地址并添加新地址
    ip addr flush dev "$name" 2>/dev/null || true
    if ! ip addr add "$vip_cidr" dev "$name" 2>/dev/null; then
      echo "$(date) $name: 添加 IP 地址失败" >&2
      return 1
    fi
  fi
  
  # 启动接口
  if ! ip link set "$name" up 2>/dev/null; then
    echo "$(date) $name: 启动接口失败" >&2
    return 1
  fi
  
  # 添加路由
  if [[ -n "$remote_vip" ]]; then
    if [[ "$remote_vip" == *:* ]]; then
      if ! ip -6 route replace "${remote_vip}/128" dev "$name" scope link src "${vip_cidr%/*}" 2>/dev/null; then
        echo "$(date) $name: 添加 IPv6 路由失败" >&2
      fi
    else
      if ! ip route replace "${remote_vip}/32" dev "$name" scope link src "${vip_cidr%/*}" 2>/dev/null; then
        echo "$(date) $name: 添加路由失败" >&2
      fi
    fi
  fi
  
  return 0
}

REMOTE_IP=""
if [[ "$DDNS_NAME" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ || "$DDNS_NAME" =~ ^[0-9a-fA-F:]+$ ]]; then
  REMOTE_IP="$DDNS_NAME"
else
  REMOTE_IP="$(resolve_ip_try "$DDNS_NAME" "$MODE")"
fi

if [[ -z "$REMOTE_IP" ]]; then
  PREV_REMOTE_LOCAL="$(cat "$STATE_FILE" 2>/dev/null || true)"
  [[ -z "$PREV_REMOTE_LOCAL" ]] && PREV_REMOTE_LOCAL="$(cat "$PERSIST_FILE" 2>/dev/null || true)"
  if [[ -n "$PREV_REMOTE_LOCAL" ]]; then
    echo "$(date) $TUN_NAME: DNS 解析失败，使用历史远端 $PREV_REMOTE_LOCAL 进行恢复" >&2
    with_lock || exit 0
    ensure_ipip_stack "$TUN_NAME" "$MODE" "$LOCAL_IP" "$PREV_REMOTE_LOCAL" "$VIP_CIDR" "$REMOTE_VIP"
    echo "$PREV_REMOTE_LOCAL" >"$STATE_FILE" 2>/dev/null || true
    exit 0
  else
    echo "$(date) $TUN_NAME: resolve failed and no previous IP" >&2
    exit 0
  fi
fi

with_lock || exit 0

PREV_REMOTE="$(cat "$STATE_FILE" 2>/dev/null || true)"
if [[ "$REMOTE_IP" == "$PREV_REMOTE" ]]; then
  ensure_ipip_stack "$TUN_NAME" "$MODE" "$LOCAL_IP" "$REMOTE_IP" "$VIP_CIDR" "$REMOTE_VIP"
  exit 0
fi

HAS_ROUTE="0"
if [[ "$MODE" == "v6" ]]; then
  if ip -6 route show | grep -qE "^${REMOTE_VIP}/128 dev ${TUN_NAME}"; then
    HAS_ROUTE="1"
  fi
else
  if ip route show | grep -qE "^${REMOTE_VIP}/32 dev ${TUN_NAME}"; then
    HAS_ROUTE="1"
  fi
fi

rollback() {
  if [[ -n "$PREV_REMOTE" ]]; then
    echo "$(date) $TUN_NAME: 配置失败，回滚到之前的远端 IP: $PREV_REMOTE" >&2
    if [[ "$MODE" == "v6" ]]; then
      ip link set "$TUN_NAME" down 2>/dev/null || true
      ip -6 tunnel del "$TUN_NAME" 2>/dev/null || true
      if ip link add name "$TUN_NAME" type ip6tnl local "$LOCAL_IP" remote "$PREV_REMOTE" mode any 2>/dev/null; then
        ip -6 addr flush dev "$TUN_NAME" 2>/dev/null || true
        ip -6 addr add "$VIP_CIDR" dev "$TUN_NAME" 2>/dev/null || true
        ip link set "$TUN_NAME" up 2>/dev/null || true
      else
        echo "$(date) $TUN_NAME: 回滚失败，无法创建 IPv6 隧道" >&2
      fi
    else
      ip link set "$TUN_NAME" down 2>/dev/null || true
      ip tunnel del "$TUN_NAME" 2>/dev/null || true
      if ip tunnel add "$TUN_NAME" mode ipip remote "$PREV_REMOTE" local "$LOCAL_IP" ttl 64 2>/dev/null; then
        ip addr flush dev "$TUN_NAME" 2>/dev/null || true
        ip addr add "$VIP_CIDR" dev "$TUN_NAME" 2>/dev/null || true
        ip link set "$TUN_NAME" up 2>/dev/null || true
      else
        echo "$(date) $TUN_NAME: 回滚失败，无法创建 IPIP 隧道" >&2
      fi
    fi
    if [[ "$HAS_ROUTE" == "1" ]]; then
      if [[ "$MODE" == "v6" ]]; then
        ip -6 route replace "${REMOTE_VIP}/128" dev "$TUN_NAME" scope link src "${VIP_CIDR%/*}" 2>/dev/null || true
      else
        ip route replace "${REMOTE_VIP}/32" dev "$TUN_NAME" scope link src "${VIP_CIDR%/*}" 2>/dev/null || true
      fi
    fi
  fi
}
trap rollback ERR

# IP 变更，重建
if ! ensure_ipip_stack "$TUN_NAME" "$MODE" "$LOCAL_IP" "$REMOTE_IP" "$VIP_CIDR" "$REMOTE_VIP"; then
  echo "$(date) $TUN_NAME: 配置失败" >&2
  exit 1
fi

# 新 IP 健康检查：如果新 IP 不通，则回滚到旧 IP
if [[ -n "$PREV_REMOTE" && -n "$REMOTE_VIP" ]]; then
  if [[ "$MODE" == "v6" ]]; then
    if ! ping6 -c1 -w2 "$REMOTE_VIP" >/dev/null 2>&1; then
      echo "$(date) $TUN_NAME: 新远端 IP $REMOTE_IP 不可达，回滚到 $PREV_REMOTE" >&2
      rollback
      exit 1
    fi
  else
    if ! ping -4 -c1 -w2 "$REMOTE_VIP" >/dev/null 2>&1; then
      echo "$(date) $TUN_NAME: 新远端 IP $REMOTE_IP 不可达，回滚到 $PREV_REMOTE" >&2
      rollback
      exit 1
    fi
  fi
fi

# 记录解析到的当前远端 IP
update_env_resolved_ip

# 重启相关的 WireGuard 接口
for conf in /etc/wireguard/*.conf; do
  [[ -f "$conf" ]] || continue
  IFACE="$(basename "$conf" .conf)"
  systemctl is-enabled "wg-quick@${IFACE}" >/dev/null 2>&1 || continue
  wg-quick down "$IFACE" >/dev/null 2>&1 || true
  wg-quick up "$IFACE" >/dev/null 2>&1 || true
done

# 保存状态
if ! echo "$REMOTE_IP" >"$STATE_FILE" 2>/dev/null; then
  echo "$(date) $TUN_NAME: 警告 - 无法保存运行时状态文件" >&2
fi
if ! echo "$REMOTE_IP" >"$PERSIST_FILE" 2>/dev/null; then
  echo "$(date) $TUN_NAME: 警告 - 无法保存持久化状态文件" >&2
fi

echo "$(date) $TUN_NAME: 配置成功，远端 IP: $REMOTE_IP" >&2
exit 0
EOF
chmod 755 /usr/local/bin/ipip-ddns-keeper.sh
